set encoding=utf-8
set tags=./tags,tags,./.git/tags;$HOME
set clipboard=unnamed
set mouse=a
set hlsearch
set incsearch
set ignorecase
set smartcase
set autoread
set noeb vb t_vb=
set statusline=%<%f\ %h%m%r%{FugitiveStatusline()}%=%-14.(%l,%c%V%)\ %P

" Cursor Styles
let &t_SI.="\e[5 q"
let &t_SR.="\e[4 q"
let &t_EI.="\e[1 q"

" Gui vs Terminal
if has("gui_running")
  set linespace=2
else
  " set termguicolors
  let g:lightline = {
        \  'colorscheme': 'default' }
endif

" set background=dark
" let g:dracula_italic = 0
" colorscheme dracula
" let g:lightline = {
"       \  'colorscheme': 'Dracula',
"       \   'inactive': {
"       \     'left': [['filename'], ['modified']],
"       \     'right': [['lineinfo'], ['percent']]
"       \   }
"       \ }

" automatically rebalance windows on resize
autocmd VimResized * :wincmd =

" zoom a vim pane, <C-w>= to re-balance
nnoremap <leader>- :wincmd _<cr>:wincmd \|<cr>
nnoremap <leader>= :wincmd =<cr>

" simplify netrw
let g:netrw_banner = 0

" display relative line numbers
set number
set numberwidth=5
set relativenumber

" set cursorline
" set cursorcolumn

" enable indent folding
set foldenable
set foldmethod=indent
set foldlevel=999

" Enable matchit for better navigating
runtime macros/matchit.vim

" Enable this for textobj-rubyblock
if has("autocmd")
  filetype indent plugin on
endif

" Remove whitespace at end of lines
autocmd BufWritePre *.erb,*.scss,*.rb,*.js,*.c,*.py,*.php,*.coffee :%s/\s\+$//e

" use C-Space to Esc any mode
nnoremap <C-Space> <Esc>:noh<CR>
vnoremap <C-Space> <Esc>gV
onoremap <C-Space> <Esc>
cnoremap <C-Space> <C-c>
inoremap <C-Space> <Esc>
" terminal sees <C-@> as <C-space>
nnoremap <C-@> <Esc>:noh<CR>
vnoremap <C-@> <Esc>gV
onoremap <C-@> <Esc>
cnoremap <C-@> <C-c>
inoremap <C-@> <Esc>

" move highlighted line up or down using option + hjkl
nnoremap ∆ :m .+1<CR>==
nnoremap ˚ :m .-2<CR>==
inoremap ∆ <Esc>:m .+1<CR>==gi
inoremap ˚ <Esc>:m .-2<CR>==gi
vnoremap ∆ :m '>+1<CR>gv=gv
vnoremap ˚ :m '<-2<CR>gv=gv

" convenience
nnoremap <leader>; :

" move between wrapped lines
nmap j gj
nmap k gk

" swap 0 and ^. I tend to want to jump to the first non-whitespace character
" so make that the easier one to do.
nnoremap 0 ^
nnoremap ^ 0

" CtrlP fuzzy buffer
nnoremap ; :CtrlPBuffer<CR>

" s toggles folds, S toggles folds recursively
nnoremap s za
nnoremap S zA

" [f]old [u]p, [u]n[f]old
nnoremap <leader>fu zM<cr>
nnoremap <leader>uf zR<cr>

" autoindent new lines with C-Return
imap <C-Return> <CR><CR><C-o>k<Tab>

let g:test#strategy = "dispatch"

" lint erb correctly
call ale#linter#Define('eruby', {
 \   'name': 'erubylint',
 \   'executable': 'erb',
 \   'output_stream': 'stderr',
 \   'command': "ruby -rerb -e \"puts ERB.new(File.read(%t, encoding: 'BINARY').gsub('<%=','<%'), nil, '-').src\" | ruby -c",
 \   'callback': 'ale#handlers#ruby#HandleSyntaxErrors',
 \})
let g:ale_linters = {
\  'javascript': ['eslint'],
\  'jsx': ['eslint']
\}
let g:ale_fixers = {
\  'javascript': ['eslint'],
\  'jsx': ['eslint']
\}

let g:EasyGrepCommand = 1

" leader space
nnoremap <leader>got <c-w>gf
nnoremap <leader>c :cclose<cr>

" vim:ft=vim
